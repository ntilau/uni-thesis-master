% Computes the far fields generated by an array of electric and
% and magnetic currents over a bounding surface, returns the power density
% and the total radiated power
%
% [EtFF, EpFF] =  vf_directffSolver(k0, z0, arrayPos, ...
%   J, M, thetaFF, phiFF)
%
% IN: k0-z0 = electrical parameters
%     arrayPos = array currents positions
%     J = electric current density vector in Cartesian coordinates
%     M = magnetic current density vector in Cartesian coordinates
%     thetaFF-phiFF = far field look angles (meshgrid)
%
% OUT: [EtFF, EpFF] = spherical components of the far electic field 
%                     detector for the choosen look angles
%
% Laurent Ntibarikure
function [EtFF, EpFF] =  vf_directffSolver(k0, z0, arrayPos, ...
  J, M, thetaFF, phiFF)

% tic
% direct integration of the sources
ExFF=zeros(size(thetaFF));
EyFF=ExFF;EzFF=ExFF;
for i=1:size(thetaFF,2)
  for j=1:size(phiFF,1)
    RffVx=sin(thetaFF(j,i)).*cos(phiFF(j,i));
    RffVy=sin(thetaFF(j,i)).*sin(phiFF(j,i));
    RffVz=cos(thetaFF(j,i));
    green=exp(1i*k0*(RffVx.*arrayPos(1,:)+ ...
      RffVy.*arrayPos(2,:) + RffVz.*arrayPos(3,:)));
    JdotRffV=J(1,:).*RffVx+ J(2,:).*RffVy+J(3,:).*RffVz;
    [McrossRffVx,McrossRffVy,McrossRffVz]=...
      crossOperator(M(1,:),M(2,:),M(3,:),RffVx,RffVy,RffVz);
    ExFF(j,i)= ExFF(j,i) - 1i*k0/(4*pi).*sum( ...
      (z0*(J(1,:)-JdotRffV.*RffVx) + McrossRffVx).*green );
    EyFF(j,i)= EyFF(j,i) - 1i*k0/(4*pi).*sum( ...
      (z0*(J(2,:)-JdotRffV.*RffVy) + McrossRffVy).*green );
    EzFF(j,i)= EzFF(j,i) - 1i*k0/(4*pi).*sum( ...
      (z0*(J(3,:)-JdotRffV.*RffVz) + McrossRffVz).*green );
  end
end
% fprintf('#> directff computation time : %g s.\n',toc)
% electric FF spherical components in [V] (exp(-jkR)/R term neglected)
[ErFF,EtFF,EpFF]=cartesian2spherical(ExFF,EyFF,EzFF,thetaFF,phiFF);