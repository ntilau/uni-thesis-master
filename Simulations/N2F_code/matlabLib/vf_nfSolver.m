% Computes the near fields E and H generated by an array of electric and
% and magnetic currents over a bounding surface, returns the power density
% and the total radiated power
%
% [E, H, S, Pr] = vf_nfSolver(k0, z0, arrayPos, surfPos, n, dS, J, M)
%
% IN: k0-z0 = electrical parameters
%     arrayPos = array currents positions
%     surfPos = surface sampling points locations
%     n = normal unit vector outwardly directed
%     dS = surface patches areas
%     J = electric current density vector in Cartesian coordinates
%     M = magnetic current density vector in Cartesian coordinates
%
% OUT: E-H = electric and magnetic fields over the surface in Cartesian
%            coordinates
%      S = Poynting vector on the surface in Cartesian coord.
%      Pr = total power radiated (active power flowing through the surface)
%
% Laurent Ntibarikure
function [E, H, S, Pr] = vf_nfSolver(k0, z0, ...
  arrayPos, surfPos, n, dS, J, M)

% Solution of the Kottler's equations
E = zeros(size(surfPos));
H = zeros(size(surfPos));

for i=1:size(arrayPos,2)
  Rx = surfPos(1,:) - arrayPos(1,i);
  Ry = surfPos(2,:) - arrayPos(2,i);
  Rz = surfPos(3,:) - arrayPos(3,i);
  R=sqrt(Rx.^2+Ry.^2+Rz.^2);
  RxV=Rx./R; RyV=Ry./R; RzV=Rz./R;
  JdotRV=J(1,i).*RxV+J(2,i).*RyV+J(3,i).*RzV;
  [JcrossRVx,JcrossRVy,JcrossRVz]= ...
    crossOperator(J(1,i),J(2,i),J(3,i),RxV,RyV,RzV);
  MdotRV=M(1,i).*RxV+M(2,i).*RyV+M(3,i).*RzV;
  [McrossRVx,McrossRVy,McrossRVz]= ...
    crossOperator(M(1,i),M(2,i),M(3,i),RxV,RyV,RzV);
  E(1,:) = E(1,:) + ...
    ( z0*k0^2/(4*pi).*( J(1,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    JdotRV.*RxV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) - k0^2/(4*pi).*...
    McrossRVx.*(1i./(k0.*R)+1./(k0.*R).^2) ).*exp(-1i*k0.*R);
  E(2,:) = E(2,:) + ...
    ( z0*k0^2/(4*pi).*( J(2,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    JdotRV.*RyV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) - k0^2/(4*pi).*...
    McrossRVy.*(1i./(k0.*R)+1./(k0.*R).^2) ).*exp(-1i*k0.*R);
  E(3,:) = E(3,:) + ...
    ( z0*k0^2/(4*pi).*( J(3,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    JdotRV.*RzV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) - k0^2/(4*pi).*...
    McrossRVz.*(1i./(k0.*R)+1./(k0.*R).^2) ).*exp(-1i*k0.*R);
  H(1,:) = H(1,:) + ...
    ( k0^2/(4*pi*z0).*( M(1,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    MdotRV.*RxV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) + k0^2/(4*pi).*...
    JcrossRVx.*(1i./(k0.*R)+1./(k0.*R).^2) ) .*exp(-1i*k0.*R);
  H(2,:) = H(2,:) + ...
    ( k0^2/(4*pi*z0).*( M(2,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    MdotRV.*RyV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) + k0^2/(4*pi).*...
    JcrossRVy.*(1i./(k0.*R)+1./(k0.*R).^2) ).*exp(-1i*k0.*R);
  H(3,:) = H(3,:) + ...
    (k0^2/(4*pi*z0).*( M(3,i).*(-1i./(k0*R)-1./(k0*R).^2+1i./(k0*R).^3) +...
    MdotRV.*RzV.*(1i./(k0*R)+3./(k0*R).^2-3i./(k0*R).^3) ) + k0^2/(4*pi).* ...
    JcrossRVz.*(1i./(k0.*R)+1./(k0.*R).^2) ).*exp(-1i*k0.*R);
end
% power density
Sp = cross(E,conj(H));
S = dot(Sp,n);
Pr=1/2*real(sum( S .* dS));

fprintf('##> Radiated power : %g Watts.\n',Pr);